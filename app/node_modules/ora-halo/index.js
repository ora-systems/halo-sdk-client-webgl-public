var Mesh        = require('pex-glu').Mesh;
var MeshExt     = require('../glu/MeshExt');
var Geometry    = require('pex-geom').Geometry;
var Vec3        = require('pex-geom').Vec3;
var Vec2        = require('pex-geom').Vec2;
var Texture2D   = require('pex-glu').Texture2D;
var makeCircle  = require('make-circle');
var HaloRingMaterial = require('ora-halo-ring-material');
var remap       = require('re-map');
var Time        = require('pex-sys').Time;
var glu         = require('pex-glu');
var SolidColor  = require('pex-materials').SolidColor;
var floor       = Math.floor;
var pow         = Math.pow;
var R           = require('ramda');
var Color       = require('pex-color').Color;
var Context     = require('pex-glu').Context;

function Halo(opts) {
  this.minRingRadius = 0.2;
  this.maxRingRadius = 1.0;
  this.minNumRings = 0;
  this.maxNumRings = 80;
  this.size = 0;
  this.speed = 0.5;
  this.color = 0;
  this.complexity = 0;
  this.brightness = 1;
  this.wobble = 0;
  this.time = 0;
  this.mode = 'present'; //'present' or 'timeline'
  this.centerHeight = 0;
  this.minCycles = 10;
  this.maxCycles = 20;
  this.stratifiedAmplitude = 1;
  this.minRingWidth = 0.02;
  this.maxRingWidth = 0.05;
  this.compactness = 2;

  this.ringInstances = [];
  this.ringMesh = this.buildMesh(opts);
}

Halo.prototype.buildMesh = function(opts) {
  var lineDotsTexture = this.lineDotsTexture = Texture2D.load(opts.lineDotsTexture, { repeat: true, mipmap: true });
  var lineSolidTexture = this.lineSolidTexture = Texture2D.load(opts.lineSolidTexture, { repeat: true, mipmap: true });
  var colorTexture = this.colorTexture = Texture2D.load(opts.colorTexture, { repeat: false, mipmap: true });
  this.material = new HaloRingMaterial({ lineTexture: lineDotsTexture, colorTexture: colorTexture } );

  return this.updateGeometry(this.mode);
}

Halo.prototype.setMode = function(mode) {
  this.mode = mode;
  this.ringInstances = [];
  this.ringMesh = this.updateGeometry(this.mode);
}

Halo.prototype.updateGeometry = function(mode) {
  if (this.mode == 'present') {
    return this.updatePresentGeometry();
  }
  else {
    return this.updateTimelineGeometry();
  }
}

Halo.prototype.updatePresentGeometry = function() {
  var numPoints = 128;
  var points    = makeCircle(1, numPoints, 'x', 'z', true);
  var texCoords = points.map(function(v, i) { return new Vec2(i/(points.length-1), 0)});
  var edges     = points.map(function(v, i) { return [ i, (i+1) % points.length ]});
  edges.pop();

  var g = new Geometry({ vertices: points, texCoords: texCoords, edges: edges  });

  if (this.ringMesh) this.ringMesh.dispose();
  return new Mesh(g, this.material, { triangles: true });
}

Halo.prototype.updateTimelineGeometry = function() {
  var numPoints = 200;
  var points          = [];
  var texCoords       = [];
  var centerPoints    = makeCircle(1, numPoints, 'x', 'z', false);
  var centerTexCoords = centerPoints.map(function(v, i) { return new Vec2(i/(centerPoints.length-1), 0)});
  var normals         = [];

  for(var i=0; i<numPoints; i++) {
    var center = centerPoints[i];
    normals.push(center);
    normals.push(center);
    var p1 = center.dup();
    var p2 = center.dup();
    points.push(p1);
    points.push(p2);
    var t1 = centerTexCoords[i];
    var t2 = t1.dup();
    t2.y = 1;
    texCoords.push(t1, t2);
  }

  var faces = [];
  var numPoints2 = numPoints * 2;
  for(var i=0; i<numPoints2; i+=2) {
    faces.push([i, (i + 1) % numPoints2, (i + 3) % numPoints2])
    faces.push([i, (i + 3) % numPoints2, (i + 2) % numPoints2])
  }

  var g = new Geometry({ vertices: points, normals: normals, texCoords: texCoords, faces: faces  });

  if (this.ringMesh) this.ringMesh.dispose();
  return new Mesh(g, this.material, { triangles: true });
}

Halo.prototype.setGlobalParam = function(param, value) {
  if (this[param] !== undefined && typeof(this[param]) !== 'function') {
    this[param] = value;
  }
}

Halo.prototype.update = function() {
  if (this.mode == 'present') {
    this.updateParams();
  }
  this.animate();
}

Halo.prototype.updateParams = function() {
  var numRings = floor(remap(this.size, 0, 1, this.minNumRings, this.maxNumRings));

  var lastRing = this.ringInstances[this.ringInstances.length-1];

  var speed = remap(this.speed, 0.0, 1.0, 0.2, 1.0);

  this.time += speed * Time.delta;

  while(this.ringInstances.length < numRings) {
    //$("#sizeSlider").slider({ change: function(event, ui) { HaloSetParam('size', ui.value/100); } })
    //$("#colorSlider").slider({ change: function(event, ui) { HaloSetParam('color', ui.value/100); } })
    //$("#complexitySlider").slider({ change: function(event, ui) { HaloSetParam('complexity', ui.value/100); } })
    //$("#speedSlider").slider({ change: function(event, ui) { HaloSetParam('speed', ui.value/100); } })
    //$("#brightnessSlider").slider({ change: function(event, ui) { HaloSetParam('brightness', ui.value/100); } })
    //$("#wobbleSlider").slider({ change: function(event, ui) { HaloSetParam('wobble', ui.value/100); } })

    this.ringInstances.push({
      uniforms: {
        radius: 1,
        color: 0,
        complexity: 0,
        speed: 0.5,
        time: lastRing ? lastRing.uniforms.time : 0,
        alpha: 0,
        brightness: 1,
        wobble: 0,
        wobbleFrequency: 0.08,
        horizontalOffset: 0,
        horizontalOffset2: 2.5,
        stratified: false
      },
      uniformsTargets: {
        radius: 1,
        color: 0,
        complexity: 0,
        speed: 0.5,
        time: 0,
        alpha: 1,
        brightness: 1,
        wobble: 0,
        wobbleFrequency: 0.08,
        horizontalOffset: 0,
        horizontalOffset2: 2.5,
        stratified: false
      },
    })
  }

  for(var i=0; i<this.ringInstances.length; i++) {
    var ring = this.ringInstances[i];
    ring.uniformsTargets.alpha = (i < numRings) ? 1 : 0;

    var k = remap(i, 0, this.maxNumRings, 0, 1);
    ring.uniformsTargets.radius = remap(Math.pow(k, this.compactness), 0, 1, this.minRingRadius, this.maxRingRadius);
    ring.uniforms.radius = remap(Math.pow(k, this.compactness), 0, 1, this.minRingRadius, this.maxRingRadius);

    ring.uniformsTargets.color = this.color;
    ring.uniformsTargets.complexity = this.complexity;
    ring.uniformsTargets.speed = remap(this.speed, 0.0, 1.0, 0.2, 1.0);
    ring.uniformsTargets.brightness = remap(this.brightness, 0.0, 1.0, 0.3, 1.0);
    ring.uniformsTargets.wobble = remap(this.wobble, 0.0, 1.0, 0.0, 1.0);
  }
}

Halo.prototype.addTimeStamp = function(params) {
  console.log('addTimeStamp', params.complexity)
  var lastRing = this.ringInstances[this.ringInstances.length-1];
  this.ringInstances.push({
    uniforms: {
      radius: this.maxRingRadius,
      color: params.color,
      complexity: params.complexity,
      speed: params.speed,
      time: 0,//lastRing ? lastRing.uniforms.time : 0,
      alpha: 0,
      brightness: 1,
      wobble: 0,
      radiusHeightScale: 1,
      radiusHeightLocalScale: 1,
      horizontalOffset: 0,
      horizontalOffset2: 2.5,
      stratified: true
    },
    uniformsTargets: {
      radius: this.maxRingRadius,
      color: params.color,
      complexity: params.complexity,
      speed: params.speed,
      time: 0,
      alpha: 1,
      brightness: 1,
      wobble: 0,
      radiusHeightScale: 1,
      radiusHeightLocalScale: 1,
      horizontalOffset: 0,
      horizontalOffset2: 0,
      stratified: true
    },
  })

  if (this.ringInstances.length > this.maxNumRings) {
    this.ringInstances.shift();
  }

  for(var i=0; i<this.ringInstances.length; i++) {
    var ring = this.ringInstances[i];
    var k = remap(i, 0, this.maxNumRings, 0, 1);
    ring.uniformsTargets.radius = remap(Math.pow(k, this.compactness), 0, 1, this.minRingRadius, this.maxRingRadius);
  }

  //if (this.rings)
}

Halo.prototype.animate = function() {
  for(var i=0; i<this.ringInstances.length; i++) {
    var k = remap(i, 0, this.maxNumRings, 0, 1);
    var ring = this.ringInstances[i];

    ring.uniforms.radiusHeightScale = remap(i, 0, this.maxNumRings, 0, 1);
    ring.uniforms.radiusHeightLocalScale = remap(i, 0, this.ringInstances.length, 0, 1);
    ring.uniforms.radius      += (ring.uniformsTargets.radius - ring.uniforms.radius) * 0.05;
    ring.uniforms.color       += (ring.uniformsTargets.color - ring.uniforms.color) * 0.05;
    ring.uniforms.complexity  += (ring.uniformsTargets.complexity - ring.uniforms.complexity) * 0.05;
    ring.uniforms.speed       += (ring.uniformsTargets.speed - ring.uniforms.speed) * 0.05;
    ring.uniforms.brightness  += (ring.uniformsTargets.brightness - ring.uniforms.brightness) * 0.05;
    ring.uniforms.alpha       += (ring.uniformsTargets.alpha - ring.uniforms.alpha) * 0.02;
    ring.uniforms.wobble      += (ring.uniformsTargets.wobble - ring.uniforms.wobble) * 0.02;
    if (this.mode == 'present') {
      ring.uniforms.time        = this.time;
    }
    else {
      ring.uniforms.time       += ring.uniforms.speed * Time.delta;
      ring.uniforms.radius = remap(Math.pow(k, this.compactness), 0, 1, this.minRingRadius, this.maxRingRadius);
    }
    ring.uniforms.centerHeight = this.centerHeight;
    ring.uniforms.minCycles = this.minCycles;
    ring.uniforms.maxCycles = this.maxCycles;
    ring.uniforms.stratifiedAmplitude = this.stratifiedAmplitude;
    ring.uniforms.minRingWidth = this.minRingWidth;
    ring.uniforms.maxRingWidth = this.maxRingWidth;

    ring.uniforms.horizontalOffset =  5 * (Time.seconds/5 - Math.floor(Time.seconds/5));
    ring.uniforms.horizontalOffset2  = 5 * ((Time.seconds + 2.5)/5 - Math.floor((Time.seconds + 2.5)/5));

    if (ring.uniformsTargets.alpha == 0 && ring.uniforms.alpha < 0.01) {
      this.ringInstances.splice(i, 1);
      i--;
    }
  }
}

Halo.prototype.setColorTexture = function(path) {
  this.colorTexture.dispose();
  this.colorTexture = Texture2D.load(path);
  this.ringMesh.material.uniforms.colorTexture = this.colorTexture;
}

Halo.prototype.draw = function(camera) {
  if (!this.ringMesh.material.program.ready) return;
  if (this.mode == 'present') {
    glu.enableAdditiveBlending(true);
    glu.enableDepthReadAndWrite(false, false);
  }
  else {
    glu.enableBlending(false);
    glu.enableDepthReadAndWrite(true, true);
  }
  //this.ringMesh.material.uniforms.lineTexture = this.lineDotsTexture; //TEMP
  this.ringMesh.material.uniforms.lineTexture = this.lineSolidTexture;
  this.ringMesh.drawInstancesOpt(camera, this.ringInstances);
}

Halo.prototype.drawSolid = function(camera) {
  if (!this.ringMesh.material.program.ready) return;
  glu.enableAdditiveBlending(true);
  glu.enableDepthReadAndWrite(false, false);
  this.ringMesh.material.uniforms.lineTexture = this.lineSolidTexture;
  this.ringMesh.drawInstancesOpt(camera, this.ringInstances);
}


Halo.prototype.dispose = function() {
  this.mesh.material.dispose();
  this.mesh.dispose();
}

module.exports = Halo;
