var Vec3        = require('pex-math/Vec3');
var Vec2        = require('pex-math/Vec2');
var Color       = require('pex-color');
var makeCircle  = require('make-circle');
var remap       = require('re-map');
var R           = require('ramda');
//TODO: var TextBox     = require('../typo/TextBox');
var createGradient = require('create-gradient');
var isBrowser   = require('is-browser');
var io          = require('pex-io');
var glslify     = require('glslify-sync');
var geoArc      = require('geo-arc');
var MathUtils   = require('pex-math/Utils')
var interpolateFloats = require('interpolate-floats');
var floor       = Math.floor;
var pow         = Math.pow;
var smoothstep  = MathUtils.smoothstep;
var clamp       = MathUtils.clamp;
var lerp        = MathUtils.lerp;

var HALO_RING_VERT = glslify(__dirname + '/assets/HaloRing.vert')
var HALO_RING_FRAG = glslify(__dirname + '/assets/HaloRing.frag')
var HALO_AURA_VERT = glslify(__dirname + '/assets/Aura.vert')
var HALO_AURA_FRAG = glslify(__dirname + '/assets/Aura.frag')


var HaloModes = {
    PRESENT: 'present',
    TIMELINE: 'timeline'
}

if (isBrowser) {
    io.loadImage = function(url, callback) {
        var img = new Image();
        img.onload = function() {
            callback(null, img);
        }
        img.onerror = function(err) {
            console.log('err', err);
        }
        img.src = url;
    }
}


function Halo(ctx, window, opts) {
  this.ctx = ctx;
  this.window = window;
  this.minRingRadius = 0.2;
  this.maxRingRadius = 1.0;
  this.minNumRings = 10;
  this.maxNumRings = 80;
  this.tilt = 0;
  this.size = 0;
  this.speed = 0.5;
  this.lateralSpeedup = 2;
  this.horizontalNoiseScale = 1;
  this.color = 0;
  this.colorCenter = 0;
  this.colorCenterRatio = 0;
  this.complexity = 0;
  this.brightness = 1;
  this.wobble = 0;
  this.wobbleFadeout = 1;
  this.time = 0;
  this.mode = HaloModes.PRESENT;
  this.enableLabels = false;
  this.background = [0,0,0,1];
  this.backgroundTransparent = [0,0,0,0];
  this.grid = [0.75, 0.75, 0.75, 1];
  this.showGrid = true;
  this.spectrum = [[0.1,0.1,0.1,1]];
  this.growth = 0.05;
  this.glow = 0.75;
  this.scale = 40;
  this.ringResolution = 128; //32
  //if true then all rings at the same angle / clock hour will have the same freequency sync
  this.stratified = false;
  this.showAuraAtRing = -1;
  this.auraOpacity = 0.5;
  this.amplitudeScale = 1;
  this.highlightRing = 0.8;
  this.complexityFrequency = 1.2;

  this.ringInstances = [];
  this.waveInstances = [];
  this.waveIntensity = 0;
  this.waveSpeed = 0.15;
  this.waveColor = 0.5;
  this.waveCount = 0;
  this.buildMesh(opts);

  this.gridLineInstances = [];
  this.gridLineLabels = [];
  this.updateGridLines();

  this.solidLines = false;
  this.evenLineDistribution = false;

  this.buildAura();
}

Halo.prototype.buildMesh = function(opts) {
  var ctx = this.ctx;

  var lineDotsTexture = this.lineDotsTexture = ctx.createTexture2D(null, 256, 32, { repeat: true, mipmap: true });
  io.loadImage(opts.lineDotsTexture, function(err, img) {
    lineDotsTexture.update(img, img.width, img.height, { repeat: true, mipmap: true });
    ctx.bindTexture(lineDotsTexture);
  }.bind(this))

  var lineSolidTexture = this.lineSolidTexture = ctx.createTexture2D(null, 256, 32, { repeat: true, mipmap: true });
  io.loadImage(opts.lineSolidTexture, function(err, img) {
    lineSolidTexture.update(img, img.width, img.height, { repeat: true, mipmap: true });
    ctx.bindTexture(lineDotsTexture);
  }.bind(this))

  var colorTexture = this.colorTexture = ctx.createTexture2D(null, 256, 32);
  io.loadImage(opts.colorTexture, function(err, img) {
    colorTexture.update(img, img.width, img.height, { repeat: false });
  })
  var colorTextureOld = this.colorTextureOld = ctx.createTexture2D(null, 256, 32);
  io.loadImage(opts.colorTextureOld, function(err, img) {
    colorTextureOld.update(img, img.width, img.height, { repeat: false });
  })
  var colorSpectrumTexture = this.colorSpectrumTexture = ctx.createTexture2D(createGradient(this.spectrum, 256, 32), 256, 32);
  var gridColorTexture = this.gridColorTexture = ctx.createTexture2D(createGradient([this.grid], 256, 32), 256, 32);

  this.ringProgram = ctx.createProgram(HALO_RING_VERT, HALO_RING_FRAG);
  this.gridProgram = ctx.createProgram(HALO_RING_VERT, HALO_RING_FRAG);

  this.defaultRingUniforms = { lineTexture: lineDotsTexture, colorTexture: colorTexture }
  this.defaultGridUniforms = { lineTexture: lineDotsTexture, colorTexture: gridColorTexture };

  this.updateGeometry(this.mode);
}

Halo.prototype.buildAura = function() {
    var ctx = this.ctx;

    var geo = geoArc( {
        cellSize: 3, // 1 == points, 2 == lines, 3 == triangles
        x: 0, // x position of the center of the arc
        y: 0, // y position of the center of the arc
        z: 0, // z position of the center of the arc
        startRadian: 0, // start radian for the arc
        endRadian: 2 * Math.PI, // end radian for the arc
        innerRadius: 2, // inner radius of the arc
        outerRadius: 2.5, // outside radius of the arc
        numBands: 2, // subdivision from inside out
        numSlices: 40, // subdivision along curve
        drawOutline: false // if cellSize == 2 draw only the outside of the shape
    });

    var texCoords = [];

    var attributes = [
      { data: geo.positions, location: ctx.ATTRIB_POSITION },
      { data: geo.uvs, location: ctx.ATTRIB_TEX_COORD_0 }
    ];
    var indices = { data: geo.cells, usage: ctx.STATIC_DRAW };

    this.auraMesh = ctx.createMesh(attributes, indices, ctx.TRIANGLES);
    this.auraProgram = ctx.createProgram(HALO_AURA_VERT, HALO_AURA_FRAG);
}

Halo.prototype.setMode = function(mode) {
  this.mode = mode;
  this.ringInstances = [];
  this.updateGeometry(this.mode);
}

Halo.prototype.updateGeometry = function(mode) {
  var ctx = this.ctx;
  var numPoints = this.ringResolution;
  var points    = makeCircle(1, numPoints, 0, 2, true); //x,z plane
  var texCoords = points.map(function(v, i) { return [i/(points.length-1), 0]});
  var edges     = points.map(function(v, i) { return [ i, (i+1) % points.length ]});
  edges.pop();

  var attributes = [
    { data: points, location: ctx.ATTRIB_POSITION },
    { data: texCoords, location: ctx.ATTRIB_TEX_COORD_0 }
  ];
  var indices = { data: edges, usage: ctx.STATIC_DRAW };

  if (this.ringMesh) {
    //TODO: this.ringMesh.dispose();
    //TODO: this.gridMesh.dispose();
  }
  this.ringMesh = ctx.createMesh(attributes, indices, ctx.LINES);
  this.gridMesh = ctx.createMesh(attributes, indices, ctx.LINES);
}

Halo.prototype.updateGridLines = function() {
  this.gridLineInstances = [];
  var numGridLines = 10;
  for(var i=1; i<=numGridLines; i++) {
    var k = i/numGridLines;
    var k2 = this.evenLineDistribution ? k : 1.0 - (k - 1.0) * (k - 1.0);
    var radius = remap(k2, 0, 1, this.minRingRadius, this.maxRingRadius*1.1);
    this.gridLineInstances.push({
      uniforms: {
        radius: radius,
        color: 0,
        colorCenter: 0,
        colorCenterRatio: 0,
        complexity: 0,
        speed: 0.5,
        time: 0,
        alpha: 0.5,
        brightness: 1,
        wobble: 0,
        wobbleFadeout: this.wobbleFadeout,
        wobbleFrequency: 0.08,
        horizontalOffset: 0,
        horizontalOffset2: 2.5,
        stratified: this.stratified,
        amplitudeScale: this.amplitudeScale
      }
    })
    if (i >= 2 && this.enableLabels) {
      var r = '' + i/10;
      if (r == '1') r = '1.0';
      var label = new TextBox('' + r, 'Arial', 10, { origin: TextBox.Origin.Left });
      label.radius = radius;
      this.gridLineLabels[i] = label;
    }
  }
}

Halo.prototype.setGlobalParam = function(param, value) {
  if (this[param] !== undefined && typeof(this[param]) !== 'function') {
    if (param == 'background') {
        if (Array.isArray(value)) {
            this[param] = value;
        }
        else {
            this[param] = Color.fromHex(value);
        }
    }
    else if (param == 'colorTexture') {
        this.setColorTexture(value);
    }
    else if (param == 'spectrum') {
        this.setColorSpectrum(value);
    }
    else if (param == 'waveIntensity') {
        console.log('waveIntensity', value)
        this.waveCount = Math.ceil(value * 8.0);
        this.waveSpeed = 0.1 + value * 0.15;
    }
    else if (param == 'color') {
        if (!Array.isArray(value)) {
            value = [value];
        }
        if (value.length == 0) {
            value = [0]
        }
        this[param] = value;
    }
    else {
        this[param] = value;
    }


    if (param == 'minRingRadius') {
        this.updateGridLines();
    }
    if (param == 'ringResolution') {
        this.updateGeometry();
    }

    if (this.mode == HaloModes.TIMELINE) {
        for(var i=0; i<this.ringInstances.length; i++) {
            this.setTimeStampParam(i, param, value)
        }
    }
  }
}

Halo.prototype.setTimeStampParam = function(ringIndex, param, value) {
    if (ringIndex >= this.ringInstances.length) {
        return;
    }

    var ring = this.ringInstances[ringIndex];
    ring.uniforms[param] = value;
    ring.uniformsTargets[param] = value;
}

Halo.prototype.update = function() {
    var speed = remap(this.speed, 0.0, 1.0, 0.2, 1.0);
    this.time += speed * this.window.getTime().getDeltaSeconds();

    this.amplitudeScale = 2 - this.size;

    if (this.size < 0.2) {
        this.complexityFrequency = remap(this.size, 0.0, 0.2, 3.0, 2.5);
    }
    else if (this.size < 0.5) {
        this.complexityFrequency = remap(this.size, 0.2, 0.5, 2.5, 1.75);
    }
    else if (this.size < 0.5) {
        this.complexityFrequency = remap(this.size, 0.2, 0.5, 2.5, 1.5);
    }
    else {
        this.complexityFrequency = remap(this.size, 0.5, 1.0, 1.5, 1.0);
    }

  if (this.mode == HaloModes.PRESENT) {
    this.updateParams();
  }

  this.animate();
  this.updateWaves();
}

Halo.prototype.updateWaves = function() {
    var seconds = this.window.getTime().getElapsedSeconds();

    var numActiveRings = 0;
    for(var i=0; i<this.ringInstances.length; i++) {
        if (this.ringInstances[i].uniforms.opacity == 1) {
            numActiveRings = i;
        }
    }

    this.waveInstances.forEach(function(wave) {
        wave.uniforms.waveLife += this.waveSpeed * this.window.getTime().getDeltaSeconds();
        if (wave.uniforms.waveLife > 1) {
            wave.uniforms.waveLife = 0
        }

        var lastRing = this.ringInstances[Math.min(Math.floor(wave.uniforms.waveLife * this.maxNumRings), this.ringInstances.length-1)];
        var params = lastRing ? Object.keys(lastRing.uniforms) : [];
        for(var i=0; i<params.length; i++) {
            wave.uniforms[params[i]] = lastRing.uniforms[params[i]];
        }

        if (wave.uniforms.waveLife < 0.05) {
            wave.uniforms.opacity = smoothstep(0, 0.05, wave.uniforms.waveLife)
        }

        var cutoffThresold = 1;
        if (wave.uniforms.waveLife > cutoffThresold - 0.05) {
            wave.uniforms.opacity = 1.0 - clamp(smoothstep(cutoffThresold - 0.05, cutoffThresold, wave.uniforms.waveLife), 0.0, 1.0)
        }

        var i = numActiveRings * wave.uniforms.waveLife;
        var k = remap(i, 0, this.maxNumRings, 0, 1);
        var k2 = this.evenLineDistribution ? k : 1.0 - (k - 1.0) * (k - 1.0);
        wave.uniforms.radius = remap(k2, 0, 1, this.minRingRadius, this.maxRingRadius)
        wave.uniforms.color = this.waveColor;
        wave.uniforms.brightness = 1;
        wave.uniforms.alpha = 1;
    }.bind(this))

    var prevCount = this.waveInstances.length;

    if (this.waveInstances.length > this.waveCount) {
        this.waveInstances.length = this.waveCount
    }

    while(this.waveInstances.length < this.waveCount) {

        var k = (this.waveInstances.length + 1)/5
        var k2 = this.evenLineDistribution ? k : 1.0 - (k - 1.0) * (k - 1.0);

        this.waveInstances.push({
            uniforms: {
                waveLife: this.waveInstances.length / 5,
                radius: remap(k2, 0, 1, this.minRingRadius, this.maxRingRadius),
                color: this.waveColor,
                colorCenter: 0,
                colorCenterRatio: 0,
                complexity: this.complexity,
                speed: this.speed,
                time: 0,
                alpha: 1,
                opacity: 0,
                lineType: 1,
                brightness: 1,
                wobble: this.wobble,
                wobbleFadeout: this.wobbleFadeout,
                wobbleFrequency: 0.08,
                radiusHeightScale: 1,
                radiusHeightLocalScale: 1,
                horizontalOffset: 0,
                horizontalOffset2: 2.5,
                stratified: false,
                amplitudeScale: this.amplitudeScale
            },
            uniformsTargets: {
                waveLife: this.waveInstances.length / 5,
                radius: remap(k2, 0, 1, this.minRingRadius, this.maxRingRadius),
                color: this.waveColor,
                colorCenter: 0,
                colorCenterRatio: 0,
                complexity: this.complexity,
                speed: this.speed,
                time: 0,
                alpha: 1,
                opacity: 0,
                lineType: 1,
                brightness: 1,
                wobble: this.wobble,
                wobbleFadeout: this.wobbleFadeout,
                wobbleFrequency: 0.08,
                radiusHeightScale: 1,
                radiusHeightLocalScale: 1,
                horizontalOffset: 0,
                horizontalOffset2: 2.5,
                stratified: false,
                amplitudeScale: this.amplitudeScale
            }
        });
    }

    if (prevCount != this.waveInstances.length) {
        this.waveInstances.forEach(function(instance, i) {
            instance.uniforms.waveLife = i / this.waveInstances.length;
        }.bind(this))
    }
}

Halo.prototype.updateParams = function() {
  var numRings = floor(remap(this.size, 0, 1, this.minNumRings, this.maxNumRings));

  var lastRing = this.ringInstances[this.ringInstances.length-1];

  var speed = remap(this.speed, 0.0, 1.0, 0.2, 1.0);

  while(this.ringInstances.length < numRings) {
    //$("#sizeSlider").slider({ change: function(event, ui) { HaloSetParam('size', ui.value/100); } })
    //$("#colorSlider").slider({ change: function(event, ui) { HaloSetParam('color', ui.value/100); } })
    //$("#complexitySlider").slider({ change: function(event, ui) { HaloSetParam('complexity', ui.value/100); } })
    //$("#speedSlider").slider({ change: function(event, ui) { HaloSetParam('speed', ui.value/100); } })
    //$("#brightnessSlider").slider({ change: function(event, ui) { HaloSetParam('brightness', ui.value/100); } })
    //$("#wobbleSlider").slider({ change: function(event, ui) { HaloSetParam('wobble', ui.value/100); } })

    this.ringInstances.push({
      uniforms: {
        radius: 1,
        color: 0,
        colorCenter: 0,
        colorCenterRatio: 0,
        complexity: lastRing ? lastRing.uniforms.complexity : 0,
        speed: 0.5,
        time: lastRing ? lastRing.uniforms.time : 0,
        alpha: 0,
        opacity: 1,
        lineType: 0,
        brightness: 1,
        wobble: 0,
        wobbleFadeout: this.wobbleFadeout,
        wobbleFrequency: 0.08,
        horizontalOffset: 0,
        horizontalOffset2: 2.5,
        stratified: this.stratified,
        amplitudeScale: this.amplitudeScale
      },
      uniformsTargets: {
        radius: 1,
        color: 0,
        colorCenter: 0,
        colorCenterRatio: 0,
        complexity: lastRing ? lastRing.uniforms.complexity : 0,
        speed: 0.5,
        time: 0,
        alpha: 1,
        opacity: 1,
        lineType: 0,
        brightness: 1,
        wobble: 0,
        wobbleFadeout: this.wobbleFadeout,
        wobbleFrequency: 0.08,
        horizontalOffset: 0,
        horizontalOffset2: 2.5,
        stratified: this.stratified,
        amplitudeScale: this.amplitudeScale
      },
    })
  }

  while(this.ringInstances.length > 0 && this.ringInstances.length > this.maxNumRings) {
      this.ringInstances.pop();
  }

  var hasColorGradient = (this.color.length > 1);
  for(var i=0; i<this.ringInstances.length; i++) {
    var ring = this.ringInstances[i];
    ring.uniformsTargets.alpha = (i < numRings) ? 1 : 0;
    if (ring.uniformsTargets.alpha == 0) {
      ring.uniforms.alpha = 0;
    }

    var k = remap(i, 0, this.maxNumRings, 0, 1);
    var k2 = this.evenLineDistribution ? k : 1.0 - (k - 1.0) * (k - 1.0);
    ring.uniformsTargets.radius = remap(k2, 0, 1, this.minRingRadius, this.maxRingRadius);
    ring.uniforms.radius = remap(k2, 0, 1, this.minRingRadius, this.maxRingRadius);


    ring.uniformsTargets.color = interpolateFloats(this.color, i/this.ringInstances.length);
    ring.uniformsTargets.colorCenter = hasColorGradient ? 0 : this.colorCenter;
    ring.uniformsTargets.colorCenterRatio = hasColorGradient ? 0 : this.colorCenterRatio;
    ring.uniformsTargets.complexity = this.complexity;
    ring.uniformsTargets.speed = remap(this.speed, 0.0, 1.0, 0.2, 1.0);
    ring.uniformsTargets.brightness = remap(this.brightness, 0.0, 1.0, 0.3, 1.0);
    ring.uniformsTargets.wobble = remap(this.wobble, 0.0, 1.0, 0.0, 1.0);
  }
}

Halo.prototype.addTimeStamp = function(params) {
  if (this.ringInstances.length >= this.maxNumRings) {
      return;
  }
  var lastRing = this.ringInstances[this.ringInstances.length-1];
  var k = remap(this.ringInstances.length, 0, this.maxNumRings, 0, 1);
  var k2 = this.evenLineDistribution ? k : 1.0 - (k - 1.0) * (k - 1.0);

  this.ringInstances.push({
    uniforms: {
      radius: remap(k2, 0, 1, this.minRingRadius, this.maxRingRadius),
      color: params.color,
      colorCenter: params.colorCenter,
      colorCenterRatio: params.colorCenterRatio,
      complexity: this.complexity,
      speed: params.speed || this.speed,
      time: 0,//lastRing ? lastRing.uniforms.time : 0,
      alpha: 0,
      opacity: (params.opacity !== undefined) ? params.opacity : 1,
      lineType: (params.lineType !== undefined) ? params.lineType : 0,
      brightness: 1,
      wobble: this.wobble,
      wobbleFadeout: this.wobbleFadeout,
      wobbleFrequency: 0.08,
      radiusHeightScale: 1,
      radiusHeightLocalScale: 1,
      horizontalOffset: 0,
      horizontalOffset2: 2.5,
      stratified: this.stratified,
      amplitudeScale: this.amplitudeScale
    },
    uniformsTargets: {
      radius: 1,
      color: params.color,
      colorCenter: params.colorCenter,
      colorCenterRatio: params.colorCenterRatio,
      complexity: this.complexity,
      speed: params.speed || this.speed,
      time: 0,
      alpha: 1,
      opacity: (params.opacity !== undefined) ? params.opacity : 1,
      lineType: (params.lineType !== undefined) ? params.lineType : 0,
      brightness: 1,
      wobble: 0,
      radiusHeightScale: 1,
      radiusHeightLocalScale: 1,
      horizontalOffset: 0,
      horizontalOffset2: 0,
      stratified: this.stratified,
      amplitudeScale: this.amplitudeScale
    },
  })

  for(var i=0; i<this.ringInstances.length - this.maxNumRings; i++) {
      //this.ringInstances.shift();
      this.ringInstances[i].uniformsTargets.alpha = 0;
  }

  for(var i=0; i<this.ringInstances.length; i++) {
    var ring = this.ringInstances[i];
    var k = remap(i, 0, this.maxNumRings, 0, 1);
    var k2 = this.evenLineDistribution ? k : 1.0 - (k - 1.0) * (k - 1.0);
    ring.uniformsTargets.radius = remap(k2, 0, 1, this.minRingRadius, this.maxRingRadius);
  }
}

Halo.prototype.animate = function() {
  for(var i=0; i<this.ringInstances.length; i++) {
    var ring = this.ringInstances[i];

    var maxHeightFadeout = remap(i, 0, this.maxNumRings, 0, 1);
    var minHeightFadeout = clamp(remap(i, 0, (this.minNumRings + this.size * (this.maxNumRings - this.minNumRings)), 0, 1), 0, 1);
    ring.uniforms.radiusHeightScale = this.ringInstances.length/this.maxNumRings;
    ring.uniforms.radiusHeightLocalScale = clamp(remap((i+1)/this.maxNumRings, 0, this.size, 0, 1), 0, 1);
    ring.uniforms.radius      += (ring.uniformsTargets.radius - ring.uniforms.radius) * this.growth;
    ring.uniforms.color       += (ring.uniformsTargets.color - ring.uniforms.color) * this.growth;
    ring.uniforms.colorCenter      += (ring.uniformsTargets.colorCenter - ring.uniforms.colorCenter) * this.growth;
    ring.uniforms.colorCenterRatio += (ring.uniformsTargets.colorCenterRatio - ring.uniforms.colorCenterRatio) * this.growth;
    ring.uniforms.complexity  += (ring.uniformsTargets.complexity - ring.uniforms.complexity) * this.growth;
    ring.uniforms.speed       += (ring.uniformsTargets.speed - ring.uniforms.speed) * this.growth;
    ring.uniforms.brightness  += (ring.uniformsTargets.brightness - ring.uniforms.brightness) * this.growth;
    ring.uniforms.alpha       += (ring.uniformsTargets.alpha - ring.uniforms.alpha) * this.growth/2;
    ring.uniforms.wobble      += (ring.uniformsTargets.wobble - ring.uniforms.wobble) * this.growth/2;
    ring.uniforms.index       = i/this.ringInstances.length;
    ring.uniforms.time        = this.time * 0.25;
    ring.uniforms.stratified  = this.stratified;
    ring.uniforms.highlight = 0;
    ring.uniforms.lateralSpeedup = this.lateralSpeedup;
    ring.uniforms.horizontalNoiseScale = this.horizontalNoiseScale;
    ring.uniforms.amplitudeScale = this.amplitudeScale;
    ring.uniforms.complexityFrequency = this.complexityFrequency;

    if (this.highlightRing) {
        var s = (i - 1) / this.maxNumRings;
        var ns = (i) / this.maxNumRings;
        if (s <= this.highlightRing && this.highlightRing < ns) {
            ring.uniforms.highlight = 4 * this.window.getPixelRatio();
        }
    }

    var seconds = this.window.getTime().getElapsedSeconds();

    ring.uniforms.horizontalOffset =  this.stratified ? 0.05 * (seconds/5 - Math.floor(seconds/5)) : 5 * (seconds/5 - Math.floor(seconds/5));
    ring.uniforms.horizontalOffset2  = this.stratified ? 0.05 * ((seconds + 2.5)/5 - Math.floor((seconds + 2.5)/5)) : 5 * ((seconds + 2.5)/5 - Math.floor((seconds + 2.5)/5));


    if (ring.uniformsTargets.alpha == 0 && ring.uniforms.alpha < 0.01) {
      this.ringInstances.splice(i, 1);
      i--;
    }
  }


  for(var i=0; i<this.ringInstances.length; i++) {
    var ring = this.ringInstances[i];
    var k = remap(i, 0, this.maxNumRings, 0, 1);
    var k2 = this.evenLineDistribution ? k : 1.0 - (k - 1.0) * (k - 1.0);
    ring.uniformsTargets.radius = remap(k2, 0, 1, this.minRingRadius, this.maxRingRadius);
  }
}

Halo.prototype.setColorTexture = function(path) {
    io.loadImage(path, function(err, img) {
        if (err) {
            console.log(err);
            return;
        }
        console.log('old', this.colorTexture.getWidth(), this.colorTexture.getHeight())
        console.log('new', img.width, img.height)
        this.colorTexture.update(img, img.width, img.height)
    }.bind(this))
}

Halo.prototype.setColorSpectrum = function(colors) {
    this.spectrum = colors;
    var tex = this.colorSpectrumTexture;
    console.log('Halo.setColorSpectrum', colors, tex.getWidth(), tex.getHeight());

    var gradient = createGradient(colors, tex.getWidth(), tex.getHeight());
    tex.update(gradient);
    this.defaultRingUniforms.colorTexture = this.colorSpectrumTexture
}

Halo.prototype.drawMeshInstances = function(ctx, camera, program, instances, defaultUniforms) {
  ctx.bindProgram(program);
  ctx.bindMesh(this.ringMesh);

  var numTextures = 0;
  for (uniformName in defaultUniforms) {
      if (program.hasUniform(uniformName)) {
          ctx.bindTexture(defaultUniforms[uniformName], numTextures)
          program.setUniform(uniformName, numTextures);
          numTextures++;
      }
  }

  for (var i = 0; i < instances.length; i++) {
    var instance = instances[i];
    if (instance.uniforms.highlight) {
        ctx.pushState(ctx.LINE_WIDTH_BIT);
        ctx.setLineWidth(instance.uniforms.highlight);
        instance.uniforms.color = -1;
    }
    for (uniformName in instance.uniforms) {
        if (program.hasUniform(uniformName)) {
            program.setUniform(uniformName, instance.uniforms[uniformName])
        }
    }
    ctx.drawMesh();
    if (instance.uniforms.highlight) {
        ctx.popState();
    }
  }
}

Halo.prototype.draw = function(camera, camera2D, w, h) {
  var ctx = this.ctx;

  this.defaultRingUniforms.lineTexture = this.solidLines ? this.lineSolidTexture : this.lineDotsTexture;

  ctx.pushModelMatrix()
  ctx.rotate(this.tilt/180*Math.PI, [1, 0, 0])

  ctx.pushState(ctx.LINE_WIDTH_BIT);
  //ctx.setLineWidth(this.solidLines ? 1 : 2);
  ctx.setLineWidth(1);
  this.drawMeshInstances(ctx, camera, this.ringProgram, this.ringInstances, this.defaultRingUniforms)
  ctx.setLineWidth(2);
  this.drawMeshInstances(ctx, camera, this.ringProgram, this.waveInstances, this.defaultRingUniforms)
  ctx.setLineWidth(2);
  if (this.showGrid) {
      this.drawMeshInstances(ctx, camera, this.gridProgram, this.gridLineInstances, this.defaultGridUniforms)
  }
  ctx.popState();

  if (this.showAuraAtRing > -1) {
      ctx.bindProgram(this.auraProgram);
      this.auraProgram.setUniform('opacity', this.auraOpacity);
      ctx.bindMesh(this.auraMesh);
      ctx.drawMesh();
  }

  //TODO: this.gridLineLabels.forEach(function(label, i) {
    //var pos = camera.getScreenPos({ x: 0, y: 0, z:  label.radius * 2}, w, h);
    //var pos3 = label._position;
    //pos3.copy(pos);
    //label.setPosition(pos3);
    //label.draw(camera2D);
  //}.bind(this));

  ctx.popModelMatrix()
}

Halo.prototype.drawSolid = function(camera) {
  var ctx = this.ctx;

  ctx.pushModelMatrix()
  ctx.rotate(this.tilt/180*Math.PI, [1, 0, 0])

  this.backgroundTransparent[0] = this.background[0];
  this.backgroundTransparent[1] = this.background[1];
  this.backgroundTransparent[2] = this.background[2];
  ctx.pushState(ctx.LINE_WIDTH_BIT);
  ctx.setLineWidth(3 * this.window.getPixelRatio());

  this.defaultRingUniforms.lineTexture = this.lineSolidTexture;
  this.drawMeshInstances(ctx, camera, this.ringProgram, this.ringInstances, this.defaultRingUniforms);
  this.drawMeshInstances(ctx, camera, this.ringProgram, this.waveInstances, this.defaultRingUniforms)
  ctx.popState();

  ctx.popModelMatrix()
}

Halo.prototype.dispose = function() {
  this.mesh.material.dispose();
  this.mesh.dispose();
}

Halo.HaloModes = HaloModes;

module.exports = Halo;
