float remap(float v, float oldmin, float oldmax, float newmin, float newmax) {
  return newmin + (v - oldmin)/(oldmax - oldmin)*(newmax - newmin);
}

uniform mat4 uProjectionMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uModelMatrix;

uniform float radius;
uniform float radiusHeightScale;
uniform float radiusHeightLocalScale;
uniform float complexity;
uniform float time;
uniform float time5;
uniform float speed;
uniform float wobble;
uniform float wobbleFadeout;
uniform float wobbleFrequency;
uniform float horizontalOffset;
uniform float horizontalOffset2;
uniform float amplitudeScale;
uniform float lateralSpeedup;
uniform float horizontalNoiseScale;
uniform float complexityFrequency;
uniform bool stratified;

attribute vec3 aPosition;
attribute vec2 aTexCoord0;

varying vec2 vTexCoord;

const float PI = 3.14159265359;

#pragma glslify: cnoise2 = require(glsl-noise/classic/2d)
#pragma glslify: cnoise3 = require(glsl-noise/classic/3d)

void main() {
  float t = aTexCoord0.x;
  vec3 pos = aPosition.xyz;
  if (!stratified) {
    pos *= radius;
  }
  float x = pos.x;
  float z = pos.z;
  float nx = x * 14.0; //remaping 0..1 to 3..14 radius of original halo
  float nz = z * 14.0; //remaping 0..1 to 3..14 radius of original halo
  float horizontalNoiseScaleValue = horizontalNoiseScale;
  if (stratified) {
    pos *= radius;
    x *= radius;
    z *= radius;
    horizontalNoiseScaleValue = 0.5;
  }



  float sinValue = sin( t * PI * 2.0 );
  float cosValue = cos( t * PI * 2.0 );

  float rampedComplexity = complexity;
  float frequency = remap(rampedComplexity, 0.0, 1.0, 0.1, complexityFrequency);
  float amplitude = radiusHeightScale * (1.0 - (1.0 - radiusHeightLocalScale) * (1.0 - radiusHeightLocalScale)); //remaping 0..1 to 3..14 radius of original halo

  float amplitude2 = 3.0 * (1.0 - (1.0 - radiusHeightLocalScale) * (1.0 - radiusHeightLocalScale)); //remaping 0..1 to 3..14 radius of original halo

  float horizontalFrequency = rampedComplexity * 1.0 * complexityFrequency;
  float horizontalAmplitude = horizontalNoiseScaleValue * radiusHeightScale * amplitude2 * complexity; //remaping 0..1 to 3..14 radius of original halo
  float horizontalSpeed = speed;
  float horizontalOffsetAmplitude = amplitudeScale * sin(horizontalOffset/5.0 * PI) / 5.0; //remaping 0..1 to 3..14 radius of original halo
  float horizontalOffsetAmplitude2 = amplitudeScale * sin(horizontalOffset2/5.0 * PI) / 5.0; //remaping 0..1 to 3..14 radius of original halo
  float wobbleAmplitude = wobble * (1.0 - wobbleFadeout + (wobbleFadeout * radiusHeightLocalScale * amplitude));

  vec2 noiseDir = vec2(frequency * nx + time * (speed + lateralSpeedup), frequency * nz + time * (speed + lateralSpeedup));

  vec2 wobbleDir = vec2( wobbleFrequency * nx + time * speed, wobbleFrequency * nz + time * speed );

  float y = amplitudeScale * amplitude * ( 0.5 + 0.5 * cnoise2( noiseDir ));

  vec2 horizontalNoiseDir = vec2( horizontalFrequency * nx, horizontalFrequency * nz);
  horizontalNoiseDir -= normalize(horizontalNoiseDir) * horizontalOffset;

  vec2 horizontalNoiseDir2 = vec2( horizontalFrequency * nx, horizontalFrequency * nz);
  horizontalNoiseDir2 -= normalize(horizontalNoiseDir2) * horizontalOffset2;

  float perlin1 = cnoise2( horizontalNoiseDir );
  float perlin2 = cnoise2( horizontalNoiseDir2 );
  float perlin3 = cnoise2( wobbleDir );

  x += horizontalOffsetAmplitude * horizontalAmplitude * ( perlin1 ) * cosValue;
  z += horizontalOffsetAmplitude * horizontalAmplitude * ( perlin1 ) * sinValue;

  x += horizontalOffsetAmplitude2 * horizontalAmplitude * ( perlin2 ) * cosValue;
  z += horizontalOffsetAmplitude2 * horizontalAmplitude * ( perlin2 ) * sinValue;

  //wobble
  x += wobbleAmplitude * ( perlin3 ) * cosValue;
  z += wobbleAmplitude * ( perlin3 ) * sinValue;

  pos.x += x;
  pos.y = y;
  pos.z += z;

  vTexCoord = aTexCoord0;

  gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(pos, 1.0);
}
