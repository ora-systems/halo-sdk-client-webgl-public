float remap(float v, float oldmin, float oldmax, float newmin, float newmax) {
  return newmin + (v - oldmin)/(oldmax - oldmin)*(newmax - newmin);
}

#ifdef VERT

uniform mat4 projectionMatrix;
uniform mat4 modelViewMatrix;

uniform float radius;
uniform float radiusHeightScale;
uniform float radiusHeightLocalScale;
uniform float complexity;
uniform float time;
uniform float time5;
uniform float speed;
uniform float wobble;
uniform float wobbleFrequency;
uniform float horizontalOffset;
uniform float horizontalOffset2;

uniform bool stratified;
uniform float centerHeight;
uniform float minCycles;
uniform float maxCycles;
uniform float stratifiedAmplitude;
uniform float minRingWidth;
uniform float maxRingWidth;

attribute vec3 position;
attribute vec3 normal;
attribute vec2 texCoord;

varying vec2 vTexCoord;

const float PI = 3.14159265359;

#pragma glslify: cnoise2 = require(glsl-noise/classic/2d)
#pragma glslify: cnoise3 = require(glsl-noise/classic/3d)

void main() {
  float t = texCoord.x;
  float normalDir = (texCoord.y - 0.5) * 2.0;
  float width =  remap(2.0 * abs(complexity - 0.5), 0.0, 1.0, minRingWidth, maxRingWidth);
  vec3 pos = position.xyz;

  if (!stratified) {
    pos *= radius;
  }
  float x = pos.x;
  float z = pos.z;
  float nx = x * 14.0; //remaping 0..1 to 3..14 radius of original halo
  float nz = z * 14.0; //remaping 0..1 to 3..14 radius of original halo

  float horizontalNoiseScale = 1.0;

  if (stratified) {
    pos *= radius;
    x *= radius;
    z *= radius;
    horizontalNoiseScale = 0.5;
    pos += normalDir * normal * width;
  }

  float sinValue = sin( t * PI * 2.0 );
  float cosValue = cos( t * PI * 2.0 );

  float rampedComplexity = 1.0 - (1.0-complexity) * (1.0-complexity);

  float frequency = remap(rampedComplexity, 0.0, 1.0, 0.1, 1.2);
  float amplitude = radiusHeightScale * (1.0 - (1.0 - radiusHeightLocalScale) * (1.0 - radiusHeightLocalScale)); //remaping 0..1 to 3..14 radius of original halo
  //float amplitude = radiusHeightLocalScale * radiusHeightLocalScale; //remaping 0..1 to 3..14 radius of original halo

  float amplitude2 = 3.0 * (1.0 - (1.0 - radiusHeightLocalScale) * (1.0 - radiusHeightLocalScale)); //remaping 0..1 to 3..14 radius of original halo

  float horizontalFrequency = rampedComplexity * 2.0;
  float horizontalAmplitude = horizontalNoiseScale * radiusHeightScale * amplitude2 * complexity; //remaping 0..1 to 3..14 radius of original halo
  float horizontalSpeed = speed;
  float horizontalOffsetAmplitude = sin(horizontalOffset/5.0 * PI) / 5.0; //remaping 0..1 to 3..14 radius of original halo
  float horizontalOffsetAmplitude2 = sin(horizontalOffset2/5.0 * PI) / 5.0; //remaping 0..1 to 3..14 radius of original halo
  float wobbleAmplitude = wobble * radiusHeightLocalScale * amplitude;

  vec2 noiseDir = vec2(frequency * nx + time * speed, frequency * nz + time * speed);

  vec2 wobbleDir = vec2( wobbleFrequency * nx + time * speed, wobbleFrequency * nz + time * speed );

  float y = 0.0;

  if (!stratified) {
    y = amplitude * ( 0.5 + 0.5 * cnoise2( noiseDir ));
    vec2 horizontalNoiseDir = vec2( horizontalFrequency * nx, horizontalFrequency * nz);
    horizontalNoiseDir -= normalize(horizontalNoiseDir) * horizontalOffset;

    vec2 horizontalNoiseDir2 = vec2( horizontalFrequency * nx, horizontalFrequency * nz);
    horizontalNoiseDir2 -= normalize(horizontalNoiseDir2) * horizontalOffset2;

    float perlin1 = cnoise2( horizontalNoiseDir );
    float perlin2 = cnoise2( horizontalNoiseDir2 );

    x += horizontalOffsetAmplitude * horizontalAmplitude * ( perlin1 ) * cosValue;
    z += horizontalOffsetAmplitude * horizontalAmplitude * ( perlin1 ) * sinValue;

    x += horizontalOffsetAmplitude2 * horizontalAmplitude * ( perlin2 ) * cosValue;
    z += horizontalOffsetAmplitude2 * horizontalAmplitude * ( perlin2 ) * sinValue;
  }
  else {
    y = stratifiedAmplitude * amplitude * (0.2 + 0.8*complexity) * sin((t + time * speed / 5.0) * 2.0 * PI * floor(minCycles + complexity * (maxCycles - minCycles)));
    //y = amplitude * (0.0 + 0.8*complexity) * sin(t * 2.0 * PI * floor(16.0));
  }

  //wobble
  float perlin3 = cnoise2( wobbleDir );
  x += wobbleAmplitude * ( perlin3 ) * cosValue;
  z += wobbleAmplitude * ( perlin3 ) * sinValue;

  if (stratified) {
    y += centerHeight * (1.0 - radiusHeightLocalScale);
  }

  pos.x += x;
  pos.y = y;
  pos.z += z;


  vTexCoord = texCoord;

  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
}

#endif

#ifdef FRAG

uniform sampler2D lineTexture;
uniform sampler2D colorTexture;
uniform float radiusHeightScale;

uniform float radius;
uniform float complexity;
uniform float color;
uniform float brightness;
uniform float alpha;

varying vec2 vTexCoord;

void main() {
  vec2 lineTextureScale = vec2(floor(150.0 * radius * (1.0 + complexity)), 1.0);
  vec4 linePattern = texture2D(lineTexture, vTexCoord * lineTextureScale);
  vec4 lineColor  = texture2D(colorTexture, vec2(color, 0.5));

  gl_FragColor = linePattern * lineColor;

  gl_FragColor *= alpha * brightness;

  //debug
  //gl_FragColor = vec4(1.0, alpha, 0.0, 1.0);
}

#endif
